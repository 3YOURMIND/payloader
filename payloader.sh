#!/bin/bash -e
# Created by argbash-init v2.6.1
# ARG_OPTIONAL_SINGLE([header],[h],[a file to use as header],['install.sh.in'])
# ARG_OPTIONAL_BOOLEAN([binary],[b],[should we append binary payload (and implicit default: off)])
# ARG_POSITIONAL_SINGLE([payload],[ a random file for payload],[])
# ARG_DEFAULTS_POS()
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.0a one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='hb'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_payload=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_header='install.sh.in'
_arg_binary="off"

print_help ()
{
  printf 'Usage: %s [-h|--header <arg>] [-b|--(no-)binary] <payload>\n' "$0"
  printf '\t%s\n' "<payload>:  a random file for payload"
  printf '\t%s\n' "-h,--header: a file to use as header (default: ''install.sh.in'')"
  printf '\t%s\n' "-b,--binary,--no-binary: should we append binary payload (and implicit default: off) (off by default)"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -h|--header)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_header="$2"
        shift
        ;;
      --header=*)
        _arg_header="${_key##--header=}"
        ;;
      -h*)
        _arg_header="${_key##-h}"
        ;;
      -b|--no-binary|--binary)
        _arg_binary="on"
        test "${1:0:5}" = "--no-" && _arg_binary="off"
        ;;
      -b*)
        _arg_binary="on"
        _next="${_key##-b}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'payload'"
  test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
  test ${#_positionals[@]} -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_payload' )

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#  <-- needed because of Argbash`
if test "$_arg_binary" = 'on'
then
  sed \
    -e 's/uuencode=./uuencode=0/' \
    -e 's/binary=./binary=1/' \
                         $_arg_header > ${_arg_payload}.sh
  echo "PAYLOAD:" >> ${_arg_payload}.sh
        cat $_arg_payload >> ${_arg_payload}.sh
fi

if test $_arg_binary = 'off'
then
  sed \
    -e 's/uuencode=./uuencode=1/' \
    -e 's/binary=./binary=0/' \
        $_arg_header >${_arg_payload}.sh
  echo "PAYLOAD:" >> ${_arg_payload}.sh
  cat $_arg_payload | uuencode - >> ${_arg_payload}.sh
fi

# ] <-- needed because of Argbash
